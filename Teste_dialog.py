# -*- coding: utf-8 -*-
"""
/***************************************************************************
 TesteDialog
                                 A QGIS plugin
 Teste apenas
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2023-06-23
        git sha              : $Format:%H$
        copyright            : (C) 2023 by Tchéllo
        email                : marcelo_lopes93@hotmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import sys
from pathlib import Path

import numpy as np
from PyQt5.QtWidgets import QApplication, QFileDialog, QMainWindow, QPushButton, QInputDialog, QLineEdit
from PyQt5.QtGui import *
from PyQt5.QtCore import *
from qgis.core import *
from qgis.gui import *
from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
import geopandas as gpd
from qgis.utils import reloadPlugin
from qgis.core import QgsProject
from shapely import wkt
from qgis.core import (QgsProject, QgsVectorLayer)
import pandas as pd
from shapely.geometry import mapping, shape, geo
import fiona
import decimal
import time

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'Teste_dialog_base.ui'))

class TesteDialog(QtWidgets.QDialog, FORM_CLASS):


    def __init__(self, parent=None):
        """Constructor."""
        super(TesteDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)

        #bastante reload no plugin mas se testar corretamenta da para tirar
        reloadPlugin('teste')
        #names = [layer.name() for layer in QgsProject.instance().mapLayers().values()] # na forma de list compr

        # esse for ele pega as camadas do Qgis
        arquivos = {}
        nome_arquivo = []
        for lyrs in QgsProject.instance().mapLayers().values():
            arquivos[lyrs.name()] = lyrs.source()
            nome_arquivo.append(lyrs.name())


        self.atualizarcamadasreturn()

        # camadas da interseção
        self.cbCamada_inter.clear()
        interCamada = self.cbCamada_inter
        interCamada.addItems(nome_arquivo)


        interCamada.showNormal()

        interCamada.activated[str].connect(lambda text: self.intersecao())
        # camadas do dissolve
        selecao = self.cbCamadas
        selecao.addItems(nome_arquivo) # era o dicionario arquivo
        selecao.showNormal()

        self.cb1.setChecked(True)
        self.cb2.setChecked(True)



        try:
            head, tail = os.path.split(arquivos[self.cbCamadas.currentText()])

            layer = QgsVectorLayer(rf'{head}\{tail}', f'{tail}', 'ogr')  # tentando pegar mais rapidamente do proprio Qgis

            lista_campos = []
            for field in layer.fields():
                field_name = field.name()
                lista_campos.append(field_name)
        except:
            self.lbResposta.setText('Precisa adicionar uma camada no Qgis!!!')

        selecao.activated[str].connect(lambda text: self.carregarDissolver())


        try:
            #entra na função gerarInterseção
            self.pbGerarInter.clicked.connect(
                lambda: self.gerarIntersecao(self.mCb_colunasInter.checkedItems(),self.arquivos, gpd.read_file(self.arquivos[self.cbCamada_inter.currentText()], encoding="utf-8"), gpd.read_file(self.arquivos[self.cbCamadas.currentText()], encoding="utf-8"),
                                             self.cbSomarAreaInter.checkedItems()))
        except:
            pass




        k = self.pbColunas.clicked.connect(lambda ts : self.checarBox)
       # acredito que essa validação nem funcione direito/proposito
        if k:

            self.pbColunas.clicked.connect(
                lambda: self.selecionar_campos(self.cbColuna1.currentText(), self.cbColuna2.currentText(),
                                               self.cbColuna3.currentText(),
                                               self.mCb_colunasInter.checkedItems(),
                                               self.cbSomarAreaInter.checkedItems(), caminhoglobal,
                                               head, tail, self.cbCamadas.currentText()))


        else:

            self.pbColunas.clicked.connect(
                lambda: self.selecionar_campos(self.cbColuna1.currentText(), self.cbColuna2.currentText(), self.cbColuna3.currentText(), 4, 5, 6,
                                               gpd.read_file(arquivos[self.cbCamadas.currentText()], encoding="utf-8"), head, tail, self.cbCamadas.currentText()))




        selecao.activated[str].connect(lambda text : self.colocarGlobal(caminhoglobal[text]))



    #função para abrir um dialog se tiver uma pasta com mesmo nome
    def dialogpasta(self):
        QApplication.restoreOverrideCursor()
        self.pasta, ok = QInputDialog().getText(self, "Nome da pasta já existe!!!",
                                          f"{self.nomepastaintersecao},já existe. Inserir nome da pasta.DEIXAR EM BRANCO PARA SUBSTITUIR EXISTENTE", QLineEdit.Normal)
        QApplication.setOverrideCursor(Qt.WaitCursor)

    #função que abre um dialog quando o campo possuir valor null no dissolve
    def dialognull(self):
        QApplication.restoreOverrideCursor()
        self.item, ok = QInputDialog().getItem(
            self, "Caixa de dialogo",f'Os campos {",".join(self.lista_campos_null)} possuem valores NULL, escolha um campo para substituir',self.lista_campos2,0,False)
        QApplication.setOverrideCursor(Qt.WaitCursor)
            #"QInputDialog().getItem()"

    def atualizarcamadasreturn(self):
        global caminhoglobal
        arquivos = {}
        nome_arquivo = []
        for lyrs in QgsProject.instance().mapLayers().values():
            arquivos[lyrs.name()] = lyrs.source()
            nome_arquivo.append(lyrs.name())
        # verificar amanha isso
        caminhoglobal = arquivos

    def atualizarcamadas(self):
        global caminhoglobal
        arquivos = {}
        nome_arquivo = []
        for lyrs in QgsProject.instance().mapLayers().values():
            arquivos[lyrs.name()] = lyrs.source()
            nome_arquivo.append(lyrs.name())

        self.cbCamada_inter.clear()
        # nome_arquivo.insert(0, None)
        interCamada = self.cbCamada_inter
        interCamada.addItems(nome_arquivo)  # mudei arquivos
        interCamada.showNormal()

        self.cbCamadas.clear()
        selecao = self.cbCamadas
        selecao.addItems(arquivos)
        selecao.showNormal()

        caminhoglobal = arquivos


    #talvez sem função
    def checarBox(self):
        b = self.cbDissolve_Intersecao.isChecked()
        return b


    #talvez sem função
    def colocarGlobal(self,ar):
        global caminhodissolvido
        caminhodissolvido = ar


    #carrega as camadas existente no Qgis
    def carregarDissolver(self):#t,listaColunas):
        self.arquivos = {}
        nome_arquivo = []
        for lyrs in QgsProject.instance().mapLayers().values():
            self.arquivos[lyrs.name()] = lyrs.source()
            nome_arquivo.append(lyrs.name())

        head, tail = os.path.split(self.arquivos[self.cbCamadas.currentText()])

        layer = QgsVectorLayer(rf'{head}\{tail}', f'{tail}', 'ogr')  # tentando pegar mais rapidamente do proprio Qgis

        lista_campos = []
        for field in layer.fields():
            field_name = field.name()
            lista_campos.append(field_name)

        self.lista_campos2 = lista_campos

        self.cbColuna1.clear()
        self.cbColuna2.clear()
        self.cbColuna3.clear()
        self.cbSomarAreaInter.clear()
        self.mCb_colunasInter.clear()


        lista_campos.insert(0, None)

        coluna1 = self.cbColuna1
        coluna1.addItems(lista_campos)
        coluna1.showNormal()

        coluna2 = self.cbColuna2
        coluna2.addItems(lista_campos)
        coluna2.showNormal()

        coluna3 = self.cbColuna3
        coluna3.addItems(lista_campos)
        coluna3.showNormal()

        del lista_campos[0]
        colunaSomarInter = self.cbSomarAreaInter
        colunaSomarInter.addItems(lista_campos)
        colunaSomarInter.showNormal()

    #def selecionar_campos(self,coluna1,coluna2,coluna3,col_inter,inter_df,col_campos,lp,head,tail,nome_arquivo_original):
    # função principal para dissolve, faz todas as operações necessárias
    def selecionar_campos(self, coluna1, coluna2, coluna3, col_inter,col_campos, arquivos, head, tail,
                          nome_arquivo_original):
        self.lista_campos_null = []
        self.lista_campos_null.append(coluna1)
        self.lista_campos_null.append(coluna2)
        self.lista_campos_null.append(coluna3)

        self.lbResposta.setText('')
        if self.cbColuna1.currentText() == '' and self.cbColuna2.currentText() == '' and self.cbColuna3.currentText() == '':
            self.lbResposta.setText('Pelo menos um campo é necessário para dissolver')
            return

        if self.cbSomarAreaInter.currentText() != '':
            self.lbResposta.setText('Não pode selecionar campos nessa opção')
            self.cbSomarAreaInter.clear()
            return

        QApplication.setOverrideCursor(Qt.WaitCursor)

        inter_df = gpd.read_file(arquivos[self.cbCamada_inter.currentText()],
                      encoding="utf-8")

        # guarda o dataframe do arquivo que vai ser dissolvido
        #arquivos é um dicionario que será referenciado pelo valor de self.cbCamadas.currentText()
        lp = gpd.read_file(arquivos[self.cbCamadas.currentText()], encoding="utf-8")


        campos_dissolve = []
        if self.cb1.isChecked() and coluna1 != '':
            campos_dissolve.append(coluna1)
        if self.cb2.isChecked() and coluna2 != '':
            campos_dissolve.append(coluna2)
        if self.cb3.isChecked() and coluna3 != '':
            campos_dissolve.append(coluna3)

        if len(self.mCb_colunasInter.checkedItems()) == 0:
            col_inter = list(inter_df)
            col_inter.remove('geometry')


        # corrige no mapa os valores null
        #filled recebe o dataframe lp com a correção dos valores null
        lp['nomeTemporario'] = ''
        df_null = lp.replace({'abcdfghijklmnop': None})
        filled = df_null.fillna('NULL')

        #função que faz o dissolve
        df_dissolvido = filled.dissolve(by=campos_dissolve, aggfunc={
            'nomeTemporario': "sum",
        }, ).reset_index()

        df_dissolvido = df_dissolvido.drop(columns=['nomeTemporario'])
        lp = lp.drop(columns=['nomeTemporario'])

        if self.cbLegenda.isChecked():
            df_dissolvido['Leg_Dissol'] =''
            lp['ID_Legenda']=''
            filled['ID_Legenda']=''



        #coloca a legenda e substitui o null nela tmb
        for i in range(len(df_dissolvido)):
            if self.cbLegenda.isChecked():
                if len(campos_dissolve) == 1:
                    df_dissolvido['Leg_Dissol'][i] = f'[{i + 1}] {df_dissolvido[campos_dissolve[0]][i]}'
                    if 'NULL' in df_dissolvido['Leg_Dissol'][i]:
                        if df_dissolvido['Leg_Dissol'][i].count("NULL") == 1:
                            self.dialognull()
                            df_dissolvido['Leg_Dissol'][i] = df_dissolvido['Leg_Dissol'][i].replace("NULL", "")
                            for j in range(len(filled)):
                                if df_dissolvido[campos_dissolve[0]][i] == filled[campos_dissolve[0]][j]:
                                    df_dissolvido['Leg_Dissol'][i] = f'[{i + 1}] {filled[self.item][j]}'
                                    filled['ID_Legenda'][j] = df_dissolvido['Leg_Dissol'][i]

                    else:
                        for j in range(len(filled)):
                            if df_dissolvido[campos_dissolve[0]][i] == filled[campos_dissolve[0]][j]:
                                filled['ID_Legenda'][j] = df_dissolvido['Leg_Dissol'][i]
                elif len(campos_dissolve) == 2:
                    df_dissolvido['Leg_Dissol'][i] = f'[{i + 1}] {df_dissolvido[campos_dissolve[0]][i]} {df_dissolvido[campos_dissolve[1]][i]}'
                    if 'NULL' in df_dissolvido['Leg_Dissol'][i]:
                        if df_dissolvido['Leg_Dissol'][i].count("NULL") == 1:
                            df_dissolvido['Leg_Dissol'][i] = df_dissolvido['Leg_Dissol'][i].replace("NULL", "")
                            for j in range(len(filled)):
                                if df_dissolvido[campos_dissolve[0]][i] == filled[campos_dissolve[0]][j] and \
                                        df_dissolvido[campos_dissolve[1]][i] == filled[campos_dissolve[1]][j]:
                                    filled['ID_Legenda'][j] = df_dissolvido['Leg_Dissol'][i]
                        else:
                            l = []
                            self.dialognull()  # chama o dialog
                            for j in range(len(filled)):
                                if df_dissolvido[campos_dissolve[0]][i] == filled[campos_dissolve[0]][j] and \
                                        df_dissolvido[campos_dissolve[1]][i] == filled[campos_dissolve[1]][j]:
                                    df_dissolvido['Leg_Dissol'][i] = f'[{i+1}] {filled[self.item][j]}'
                                    filled['ID_Legenda'][j] = df_dissolvido['Leg_Dissol'][i]

                                    l.append(filled[self.item][j])
                            k = set(l)
                            t = list(k)
                            df_dissolvido['Leg_Dissol'][i] = f'[{i + 1}] {" ou ".join(t)}'
                    else:
                        for j in range(len(filled)):
                            if df_dissolvido[campos_dissolve[0]][i] == filled[campos_dissolve[0]][j] and df_dissolvido[campos_dissolve[1]][i] == filled[campos_dissolve[1]][j]:
                                filled['ID_Legenda'][j] = df_dissolvido['Leg_Dissol'][i]
                #elif len(campos_dissolve) == 3:
                else :
                    df_dissolvido['Leg_Dissol'][i] = f'[{i + 1}] {df_dissolvido[campos_dissolve[0]][i]} {df_dissolvido[campos_dissolve[1]][i]} {df_dissolvido[campos_dissolve[2]][i]}'
                    if 'NULL' in df_dissolvido['Leg_Dissol'][i]:
                        if df_dissolvido['Leg_Dissol'][i].count("NULL") == 1 or df_dissolvido['Leg_Dissol'][i].count("NULL") == 2:
                            df_dissolvido['Leg_Dissol'][i] = df_dissolvido['Leg_Dissol'][i].replace("NULL", "")
                            for j in range(len(filled)):
                                if df_dissolvido[campos_dissolve[0]][i] == filled[campos_dissolve[0]][j] and \
                                        df_dissolvido[campos_dissolve[1]][i] == filled[campos_dissolve[1]][j]:
                                    filled['ID_Legenda'][j] = df_dissolvido['Leg_Dissol'][i]
                        elif df_dissolvido['Leg_Dissol'][i].count("NULL") == 3:
                            l = []
                            self.dialognull()  # chama o dialog
                            for j in range(len(filled)):
                                if df_dissolvido[campos_dissolve[0]][i] == filled[campos_dissolve[0]][j] and \
                                        df_dissolvido[campos_dissolve[1]][i] == filled[campos_dissolve[1]][j]:
                                    df_dissolvido['Leg_Dissol'][i] = f'[{i+1}] {filled[self.item][j]}'
                                    filled['ID_Legenda'][j] = df_dissolvido['Leg_Dissol'][i]

                                    l.append(filled[self.item][j])
                            k = set(l)
                            t = list(k)
                            df_dissolvido['Leg_Dissol'][i] = f'[{i + 1}] {" ou ".join(t)}'
                    else:
                        for j in range(len(filled)):
                            if df_dissolvido[campos_dissolve[0]][i] == filled[campos_dissolve[0]][j] and df_dissolvido[campos_dissolve[1]][i] == filled[campos_dissolve[1]][j]\
                                    and df_dissolvido[campos_dissolve[2]][i] == filled[campos_dissolve[2]][j]:
                                filled['ID_Legenda'][j] = df_dissolvido['Leg_Dissol'][i]


        # cria o id no filled que será a copia do arquivo original
        # obrigatoriedade do Id dissolvido sem legenda
        if 'ID_Dissol' not in filled:
            filled['ID_Dissol'] = 0
        for i in range(len(df_dissolvido)):
            for j in range(len(filled)):
                if len(campos_dissolve) == 1:
                    if df_dissolvido[campos_dissolve[0]][i] == filled[campos_dissolve[0]][j]:
                        filled['ID_Dissol'][j] = i + 1
                elif len(campos_dissolve) == 2:
                #if df_dissolvido[campos_dissolve[0]][i] == filled['ordem'][j] and df_dissolvido[campos_dissolve[1]][i] == filled['grande_gru'][j]:
                    if df_dissolvido[campos_dissolve[0]][i] == filled[campos_dissolve[0]][j] and df_dissolvido[campos_dissolve[1]][i] == filled[campos_dissolve[1]][j]:
                        filled['ID_Dissol'][j] = i+1
                elif len(campos_dissolve) == 3:
                    if df_dissolvido[campos_dissolve[0]][i] == filled[campos_dissolve[0]][j] and df_dissolvido[campos_dissolve[1]][i] == filled[campos_dissolve[1]][j]\
                                and df_dissolvido[campos_dissolve[2]][i] == filled[campos_dissolve[2]][j]:
                        filled['ID_Dissol'][j] = i+1


        #cria um id no arquivo dissolvido
        df_dissolvido.insert(0, 'ID', range(1, 1 + len(df_dissolvido)))

        head, tail = os.path.split(arquivos[self.cbCamadas.currentText()])
        nome_arquivo = self.leInserirNome.text()
        # Talvez quando chegar ao 10 pode dar algum problema, corrigir
        if nome_arquivo =='':
            nome_arquivo = 'Dissolvido_1'

            # Fazer um check se tem dissolvido e adicionar até max 9?
            camadas = {}
            nome_camada = []
            for lyrs in QgsProject.instance().mapLayers().values():
                nome_camada.append(lyrs.name())
            for i in range(len(nome_camada)):
                if nome_arquivo == nome_camada[i]:
                    initial_number = int(''.join(filter(str.isdigit, nome_arquivo)))
                    string_phrase = ''.join([i for i in nome_arquivo if not i.isdigit()])
                    nome_arquivo = f'{string_phrase}{initial_number + 1}'
                    i = 0

            original_modificado = f'copia_{nome_arquivo}'
            a = original_modificado[-1]
            path2 = os.path.join(head, f'Dissolvido_{a}')
        else:
            path2 = os.path.join(head, nome_arquivo)
            original_modificado = f'copia_{nome_arquivo}'

        filled = filled.drop(columns=['nomeTemporario'])

        # coloca camada no projeto

        #voltando os nulls para valores realmente nulls
        filled = filled.replace({'NULL': None})
        df_dissolvido = df_dissolvido.replace({'NULL': None})


        df_comArea = filled.copy()
        if self.cbSomarArea.isChecked():

            df_comArea = df_comArea.to_crs({'init': 'epsg:6933'})
            df_comArea['area_km_2'] = df_comArea['geometry'].area / 10 ** 6
            df_comArea = df_comArea.to_crs({'init': 'epsg:4674'})

        #a = original_modificado[-1]
        #head, tail = os.path.split(arquivos[self.cbCamadas.currentText()])
        #path2 = os.path.join(head, f'Dissolvido_{a}')
        #os.makedirs(path2)
        # se ja tiver uma pasta com mesmo nome ela sobrepoe
        self.nomepastaintersecao = nome_arquivo
        try:
            os.makedirs(path2)
        except FileExistsError:
            self.dialogpasta()
            if self.pasta != '':
                path2 = os.path.join(head,self.pasta)
                os.makedirs(path2)
            pass

        # cria uma copia do original
        df_comArea.to_file(f'{path2}/{original_modificado}.shp',
                       driver="ESRI Shapefile", encoding="utf-8", )

        #print(head) pasta
        #print(original_modificado) shapefile

        copia = df_dissolvido.copy()
        #copia = copia.to_crs({'init': 'epsg:4674'})
        #testando area
        if self.cbSomarArea.isChecked():
            copia = copia.to_crs({'init': 'epsg:6933'})
            copia['area_km_2'] = copia['geometry'].area /10 ** 6
            copia = copia.to_crs({'init': 'epsg:4674'})


        # cria um dissolvido novo

        copia.to_file(f'{path2}/{nome_arquivo}.shp',
                      driver="ESRI Shapefile", encoding="utf-8")

        # o arquivo original modificado
        #coloca no software Qgis a camada do original modificado. mesma função é feita para o dissolvido
        layer = QgsVectorLayer(rf'{path2}\{original_modificado}.shp', f'{original_modificado}', 'ogr')
        QgsProject.instance().addMapLayer(layer)


        # shp novo dissolvido
        layer = QgsVectorLayer(rf'{path2}\{nome_arquivo}.shp', nome_arquivo, 'ogr')
        QgsProject.instance().addMapLayer(layer)

        # gera o geoJson caso o check esteja marcado
        if self.cbGeo.isChecked():
            copia.to_file(f'{head}/{original_modificado}.geojson', driver="GeoJSON")
            df_comArea.to_file(f'{head}/{nome_arquivo}.geojson', driver="GeoJSON")

        if self.cbDissolve_Intersecao.isChecked():
            self.gerarIntersecao(col_inter,arquivos,inter_df,copia,col_campos)
        self.lbResposta.setText(f'Arquivos criados com sucesso')
        QApplication.restoreOverrideCursor()
        self.atualizarcamadas()
        reloadPlugin('teste')


    #função para carregar os dados para interseção
    def intersecao(self):# sem selecao

        if self.cbDissolve_Intersecao.isChecked():
            self.cbSomarAreaInter.setEnabled(False)
        else:
            self.cbSomarAreaInter.setEnabled(True)
        self.arquivos = {}
        nome_arquivo = []
        for lyrs in QgsProject.instance().mapLayers().values():
            self.arquivos[lyrs.name()] = lyrs.source()
            nome_arquivo.append(lyrs.name())

        head, tail = os.path.split(self.arquivos[self.cbCamada_inter.currentText()])

        layer = QgsVectorLayer(rf'{head}\{tail}', f'{tail}', 'ogr')  # tentando pegar mais rapidamente do proprio Qgis

        lista_campos = []
        for field in layer.fields():
            field_name = field.name()
            lista_campos.append(field_name)

        self.mCb_colunasInter.clear()
        coluna_inter = self.mCb_colunasInter
        coluna_inter.addItems(lista_campos)
        coluna_inter.showNormal()


    #função que gera a interseção propriamente dita
    def gerarIntersecao(self,colunaSelecionada,t,inter_df,dissolvido,selecao_colunas):
        # t aqui é dicionario com os nomes das camadas
        #tirei o try para mostrar uns erros mas pode voltar se quiser
        #try:
            QApplication.setOverrideCursor(Qt.WaitCursor)
            inter_df = inter_df.to_crs(4674)
            if len(selecao_colunas) != 0:
                selecao_colunas.append('geometry')
                dissolvido = dissolvido[selecao_colunas]


            if len(colunaSelecionada) == 0:

                colunaSelecionada = list(inter_df)
                colunaSelecionada.remove('geometry')


            head, tail = os.path.split(t[self.cbCamadas.currentText()])

            nomedaintersecao = self.leInserirNome_2.text()
            if nomedaintersecao == '':
                nomedaintersecao = 'Interseção_1'

                camadas = {}
                nome_camada = []
                for lyrs in QgsProject.instance().mapLayers().values():
                    nome_camada.append(lyrs.name())

                for i in range(len(nome_camada)):
                    if nomedaintersecao == nome_camada[i]:
                        initial_number = int(''.join(filter(str.isdigit, nomedaintersecao)))
                        string_phrase = ''.join([i for i in nomedaintersecao if not i.isdigit()])
                        nomedaintersecao = f'{string_phrase}{initial_number + 1}'
                        i = 0

                a = nomedaintersecao[-1]
                path2 = os.path.join(head, f'Interseção_{a}')

            else:
                path2 = os.path.join(head,nomedaintersecao)

            colunaSelecionada.append("geometry")
            inter_df = inter_df[colunaSelecionada]

            interFinal = inter_df.overlay(dissolvido, how='intersection')
            copia = interFinal.copy()
            if self.cbSomarArea_2.isChecked():

                copia = copia.to_crs({'init': 'epsg:6933'})
                copia['area_km_2'] = copia['geometry'].area/ 10**6
                #copia['nova_area'] = copia['nova_area'].astype('float32')
                #"{:.5f}".format(float(match.group()))
                #copia.set_option('precision',0)
                copia = copia.to_crs({'init': 'epsg:4674'})


            # se ja existir uma pasta com mesmo nome ele vai sobrepor
            #talvez fazer o usuário escolher o nome depois
            self.nomepastaintersecao = nomedaintersecao
            try:
                os.makedirs(path2)
            except FileExistsError:
                self.dialogpasta()
                if self.pasta != '':
                    path2 = os.path.join(head, self.pasta)
                    os.makedirs(path2)
                pass
            #gera a intersecao
            copia.to_file(f'{path2}/{nomedaintersecao}.shp',
                           driver="ESRI Shapefile", encoding="utf-8", )

            # layer da intersecao
            layer = QgsVectorLayer(rf'{path2}\{nomedaintersecao}.shp', nomedaintersecao, 'ogr')
            QgsProject.instance().addMapLayer(layer)
            if self.cbGeo.isChecked():
                copia.to_file(f'{head}/{nomedaintersecao}.geojson', driver="GeoJSON")

            #copia.to_excel(f'{head}/teste.xlsx')


            self.atualizarcamadasreturn()
            self.atualizarcamadas()
            QApplication.restoreOverrideCursor()
            reloadPlugin('teste')
            #self.__init__()
        #except:
        #    print('aconteceu algo de errado')



